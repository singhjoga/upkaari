package org.upkaari.api.common.services;

import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import javax.inject.Inject;
import javax.persistence.Id;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;
import javax.transaction.Transactional;
import javax.validation.ConstraintViolation;
import javax.validation.Validator;

import org.apache.commons.beanutils.BeanUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.DiffBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.apache.commons.lang3.reflect.FieldUtils;
import org.eclipse.microprofile.openapi.annotations.media.Schema;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.upkaari.api.common.annotations.AutoGeneratedUUID;
import org.upkaari.api.common.annotations.LifecycleStatus;
import org.upkaari.api.common.annotations.UniqueKey;
import org.upkaari.api.common.auditlog.AuditLog;
import org.upkaari.api.common.auditlog.AuditLogService;
import org.upkaari.api.common.auditlog.Auditable;
import org.upkaari.api.common.auditlog.AuditableChild;
import org.upkaari.api.common.auditlog.AuditableMain;
import org.upkaari.api.common.auditlog.AuditableReference;
import org.upkaari.api.common.cache.EntityCacheReference.EntityReferenceCacheEntry;
import org.upkaari.api.common.constants.Actions;
import org.upkaari.api.common.constants.Actions.Crud;
import org.upkaari.api.common.constants.Operations;
import org.upkaari.api.common.controllers.CommonResponse.ErrorResponse;
import org.upkaari.api.common.controllers.CommonResponse.ValidationError;
import org.upkaari.api.common.controllers.CommonResponseBuilder;
import org.upkaari.api.common.db.EntityManagerProvider;
import org.upkaari.api.common.domain.AbstractResource;
import org.upkaari.api.common.domain.AppObect;
import org.upkaari.api.common.domain.IdentifiableEntity;
import org.upkaari.api.common.exception.BadRequestException;
import org.upkaari.api.common.exception.InvalidRequestException;
import org.upkaari.api.common.exception.ValidationException;
import org.upkaari.api.common.repos.BaseRepository;
import org.upkaari.api.common.utils.BeanUtil;
import org.upkaari.api.common.utils.CommonUtil;
import org.upkaari.api.common.utils.DateUtils;
import org.upkaari.api.common.utils.EntityUtils;

public abstract class BaseCrudService<T extends IdentifiableEntity<ID>, ID extends Serializable> extends BaseEntityService<T, ID> {
	private static final Logger LOG = LoggerFactory.getLogger(BaseCrudService.class);
	protected static final String STATUS_NEW = "N";
	protected static final String COMMA = ",";
	protected static final String STATUS_DEPRECATED = "D";

	@Inject
	private Validator validator;

	@Inject
	private AuditLogService auditService;

	private Field statusField = null;
	private String statusFieldDefault=null;
	private boolean generateKey=false;
	private boolean generateKeyOptional=false;
	private Map<String, List<Field>> uniqueKeyFields;
	public BaseCrudService(BaseRepository<T, ID> repo, Class<T> entityClass, Class<ID> idClass) {
		super(repo, entityClass, idClass);
		this.repo = repo;
		this.entityClass = entityClass;
		List<Field> fields = FieldUtils.getFieldsListWithAnnotation(entityClass, LifecycleStatus.class);
		if (fields.size() == 1) {
			statusField = fields.get(0);
			LifecycleStatus lsAnno = statusField.getAnnotation(LifecycleStatus.class);
			statusFieldDefault = lsAnno.defaultValue();
		} else if (fields.size() > 1) {
			// programming error
			throw new IllegalStateException("Only one field per entity should be set as LifeCycleStatus field");
		}
		fields = FieldUtils.getFieldsListWithAnnotation(entityClass, AutoGeneratedUUID.class);
		if (fields.size() == 1) {
			generateKey=true;
			AutoGeneratedUUID anno = fields.get(0).getAnnotation(AutoGeneratedUUID.class);
			generateKeyOptional = anno.optional();
		}
		//get unique key fields
		uniqueKeyFields=new HashMap<>();
		initUniqueKeys(entityClass, UniqueKey.class);
		//If primary key is optional, it must also be verified for uniqueness
		if (generateKeyOptional) {
			initUniqueKeys(entityClass, Id.class);
		}
	}
	private void initUniqueKeys(Class<T> entityClass, Class<? extends Annotation> annotaion) {
		List<Field> fields = FieldUtils.getFieldsListWithAnnotation(entityClass, annotaion);
		if (fields.size() != 0) {

			for (Field field: fields) {
				Annotation uk = field.getAnnotation(annotaion);
				String key;
				if (annotaion.equals(Id.class)) {
					key="id";
				}else {
					key = ((UniqueKey)uk).value();
				}
				List<Field> keyFields = uniqueKeyFields.get(key);
				if (keyFields == null) {
					keyFields = new ArrayList<>();
					uniqueKeyFields.put(key, keyFields);
				}
				keyFields.add(field);
			}
		}	
	}
	public List<AuditLog> getHistory(ID id) {
		T obj = getById(id, true);
		if (obj != null) {
			return auditService.find((AuditableMain<?>) obj, additionalHistory(id));
		} else {
			return auditService.find(getAppObjectType(), id.toString());
		}
	}

	@Transactional()
	public T add(T obj) {
		validate(obj, Operations.Add.class);
		return addInternal(obj);
	}
	@Transactional()
	public void overwrite(ID id, T obj) {
		validate(obj, Operations.Overwrite.class);
		overwriteInternal(id, obj);
	}
	@Transactional()
	public List<ID> addAll(List<T> objList) {
		validate(objList, Operations.Add.class);
		List<ID> result = new ArrayList<>();
		for (T obj : objList) {
			T ret = addInternal(obj);
			result.add(ret.getId());
		}

		return result;
	}
	@Transactional()
	public List<ID> addOrOverwriteAll(List<T> objList) {
		return addOrOverwriteAll(objList, Operations.Overwrite.class);
	}
	@Transactional()
	public List<ID> addOrUpdateAll(List<T> objList) {
		return addOrOverwriteAll(objList, Operations.Update.class);
	}
	private List<ID> addOrOverwriteAll(List<T> objList, Class<? extends Operations.Operation> operation) {
		List<ValidationError> allErrors = new ArrayList<>();
		int i=0;
		List<ID> result = new ArrayList<>();
		Set<ID> processedIds = new HashSet<>();
		for (T obj : objList) {
			i++;

			try {
				boolean exists = false;
				if (obj.getId() != null) {
					if (processedIds.contains(obj.getId())) {
						/*
						 * Duplicate Ids are not allowed in the same request
						 */
						throw new ValidationException("id", UniqueKey.class.getSimpleName(), "must be unique in request");
					}
					exists = repo.findById(obj.getId()) != null;
					processedIds.add(obj.getId());
				}

				if (!exists) {
					T ret = add(obj);
					result.add(ret.getId());
				}else {
					if (isUpdate(operation)) {
						update(obj.getId(), obj);
					}else {
						overwrite(obj.getId(), obj);
					}
					result.add(obj.getId());
				}
			} catch (ValidationException e) {
				setFieldIndex(e.getErrors(), i);
				allErrors.addAll(e.getErrors());
			}
		}
		if (!allErrors.isEmpty()) {
			throw new ValidationException(allErrors);
		}
	
		return result;
	}
	private void setFieldIndex(List<ValidationError> errors, int index) {
		for (ValidationError err: errors) {
			//put index right after the field name. If the field is a child object, then the index of child collection is already there. Parent index should come first.
			String[] fieldParts =StringUtils.split(err.getField(),'.');
			fieldParts[0]=fieldParts[0]+"."+index;

			err.setField(StringUtils.join(fieldParts,'.'));
		}
	}
	@Transactional()
	public void update(ID id, T obj) {
		validate(obj, Operations.Update.class);
		updateInternal(id, obj);
	}

	@Transactional()
	public void updateAll(List<T> objList) {
		validate(objList, Operations.Update.class);
		for (T obj : objList) {
			updateInternal(obj.getId(), obj);
		}
	}

	@Transactional()
	public void delete(ID id) {
		deleteInternal(id);
	}

	@Transactional()
	public void deleteAllForIds(List<ID> ids) {
		for (ID id : ids) {
			deleteInternal(id);
		}
	}
	@Transactional()
	public void deleteAllForIds(Set<ID> ids) {
		for (ID id : ids) {
			deleteInternal(id);
		}
	}
	@Transactional()
	public void deleteAllForObjs(List<T> objList) {
		for (T obj : objList) {
			deleteInternal(obj.getId());
		}
	}

	private void deleteInternal(ID id) {
		T saved = getById(id);
		// check of reference
		ensureNoReferences(saved);
		beforeDelete(saved);
		repo.delete(saved);
		if (saved instanceof Auditable) {
			saveHistory(Actions.Crud.Delete, (Auditable) saved, "Deleted", null);
		}
		afterDelete(saved);
		fireResourceChangeEvent(saved, Crud.Delete);
	}

	protected void verifyUniqueId(T obj, ID id) {
		T saved = findById(id);
		if (saved != null) {
			throw new BadRequestException("Functional id '" + obj.getId() + "' is already used");
		}
	}

	protected List<AuditLog> additionalHistory(ID id) {
		return null;
	}

	protected void save(T obj) {
		repo.persist(obj);
	}

	protected void beforeSave(T newObj, T oldObj, Class<? extends Operations.Operation> operation) {
		// entity specific login can come here
	}

	protected void afterSave(T newObj, T oldObj, Class<? extends Operations.Operation> operation) {
		// entity specific login can come here
	}

	protected void beforeDelete(T savedObj) {
		// entity specific login can come here
	}

	protected void afterDelete(T savedObj) {
		// entity specific login can come here
	}

	protected void saveHistory(String action, Auditable obj, String details, String filter) {
		if (obj instanceof AuditableMain) {
			auditService.add(action, (AuditableMain<?>)obj, details, filter);
		} else if (obj instanceof AuditableChild) {
			saveChildHistory(action, (AuditableChild<?>) obj, details);
		} else if (obj instanceof AuditableReference) {
			saveReferenceHistory(action, (AuditableReference<?,?>) obj, details);
		}
	}

	protected void saveChildHistory(String action, AuditableChild<?> obj, String details) {
		Object parentId = obj.getParentId();
		Object parent = EntityManagerProvider.getEntityManager().find(obj.getParentEntity(), parentId);
		if (parent == null) {
			throw new IllegalArgumentException("Parent entity '"+obj.getParentEntity().getName()+" does not exist for id: "+parentId);
		}
		String filter = obj.getAppObjectType();
		details += " [" + obj.getName() + "]";
		auditService.add(Actions.Crud.Update, (AuditableMain<?>) parent, details, filter);
	}

	protected void saveReferenceHistory(String action, AuditableReference<?,?> obj, String details) {
		Object parentId = obj.getParentId();
		//find parent entity
		Object parent = EntityManagerProvider.getEntityManager().find(obj.getParentEntity(), parentId);
		if (parent == null) {
			throw new IllegalArgumentException("Parent entity '"+obj.getParentEntity().getName()+" does not exist for id: "+parentId);
		}
		//find referenced entity
		AuditableMain<?> ref = EntityManagerProvider.getEntityManager().find(obj.getReferenceEntity(), obj.getReferenceId());
		if (ref == null) {
			throw new IllegalArgumentException("Reference entity '"+obj.getReferenceEntity().getName()+" does not exist for id: "+obj.getReferenceId());
		}
		String filter = obj.getAppObjectType();
		
		details += " [" + ref.getName() + "]";
		auditService.add(Actions.Crud.Update, (AuditableMain<?>) parent, details, filter);
	}
	
	public boolean isEqual(Object compareWith, Object obj) {
		String changes = compareAndCopy(compareWith, obj, false, false);
		return StringUtils.isEmpty(changes);
	}

	public String compareAndCopy(Object compareWith, Object obj) {
		return compareAndCopy(compareWith, obj,true, true);
	}

	public String compareAndCopy(Object compareWith, Object obj,boolean onlyNonNullValues, boolean copyValue2CompareWith) {
		DiffBuilder<Object> builder = new DiffBuilder<>(compareWith, obj, ToStringStyle.NO_CLASS_NAME_STYLE);

		for (Field field : FieldUtils.getAllFields(obj.getClass())) {
			if (field.getName().equals("serialVersionUID")) {
				continue;
			}
			field.setAccessible(true);
			Object value;
			try {
				value = BeanUtils.getProperty(obj, field.getName());
				Boolean updateable = onlyNonNullValues?value != null:true;
				boolean isTransient = isFieldTransient(field);
				if (updateable) {
					updateable = !isFieldReadOnly(field);
				}
				if (updateable && !isTransient) { //transient fields are not change detected
					Object oldValue = BeanUtils.getProperty(compareWith, field.getName());
					if (value instanceof Date) {
						Date dateValue = (Date) value;
						dateValue = adjustTemporalValue(field, dateValue, obj);
						// date is not properly formatted in diff, convert to string
						String newValueStr = null;
						String oldValueStr = null;
						;
						if (value != null) {
							newValueStr = DateUtils.formatTimestamp(dateValue) + " " + TimeZone.getDefault().getID();
						}
						if (oldValue != null) {
							oldValueStr =  DateUtils.formatTimestamp((Date) oldValue) + " " + TimeZone.getDefault().getID();
						}
						builder.append(field.getName(), oldValueStr, newValueStr);
					} else {
						builder.append(field.getName(), oldValue, value);
					}
				}
				if (updateable && copyValue2CompareWith) {
					BeanUtils.setProperty(compareWith, field.getName(), value);
				}
			} catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
				throw new IllegalStateException(e);
			}
		}
		String result = builder.build().toString();
		// replace the message
		result = StringUtils.replace(result, "differs from", "changed to");
		return result;
	}

	private void adjustTemporalFields(Object obj) {
		// truncatet the time part for the date only fields
		for (Field field : FieldUtils.getAllFields(obj.getClass())) {
			if (!field.getType().equals(Date.class)) {
				continue;
			}
			field.setAccessible(true);
			Object value;
			try {
				value = BeanUtils.getProperty(obj, field.getName());
				Date dateValue = (Date) value;
				adjustTemporalValue(field, dateValue, obj);
			} catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
				throw new IllegalStateException(e);
			}
		}

	}

	private Date adjustTemporalValue(Field field, Date value, Object obj) {
		if (value == null) {
			return null;
		}
		Temporal anno = field.getAnnotation(Temporal.class);
		if (anno == null) {
			return value;
		}
		if (anno.value() == TemporalType.DATE) {
			// remove the time part from the date
			Date newValue = DateUtils.toStartOfDay(value);
			try {
				BeanUtils.setProperty(obj, field.getName(), newValue);
			} catch (IllegalAccessException | InvocationTargetException e) {
				throw new IllegalStateException(e);
			}
			return newValue;
		}
		return value;
	}

	@SuppressWarnings("unchecked")
	private T addInternal(T obj) {
		if (obj instanceof AbstractResource) {
			setAuditData((AbstractResource<ID>) obj, Operations.Add.class);
		}
		verifyStatusField(obj);
		adjustTemporalFields(obj);
		ensureUniqueKeys(obj, null, Operations.Add.class);
		beforeSave(obj, null, Operations.Add.class);
		if (generateKey) {
			//generate key when it is not optional, or it is optional but not set. 
			if (!generateKeyOptional || (generateKeyOptional && (obj.getId() == null || StringUtils.isEmpty(obj.getId().toString())))) {
				obj.setId((ID)CommonUtil.genUUID());			
			}
		}
		save(obj);
		if (obj instanceof Auditable) {
			saveHistory(Actions.Crud.Add, (Auditable) obj, "Added", null);
		}
		afterSave(obj, null, Operations.Add.class);
		fireResourceChangeEvent(obj, Crud.Add);
		return obj;
	}
	@SuppressWarnings("unchecked")
	private void overwriteInternal(ID id, T obj) {
		if (obj.getId() != null && !obj.getId().equals(id)) {
			throw new BadRequestException("ID field cannot be updated");
		}
		obj.setId(id);
		T saved = getById(id);
		if (obj instanceof AbstractResource) {
			setAuditData((AbstractResource<ID>) obj, Operations.Overwrite.class);
		}
		verifyStatusField(obj);
		adjustTemporalFields(obj);
		ensureUniqueKeys(obj, saved, Operations.Overwrite.class);
		beforeSave(obj, saved, Operations.Overwrite.class);
		T copy = copy(saved);
		String changes = compareAndCopy(saved, obj, false, true);
		if (StringUtils.isEmpty(changes)) {
			LOG.info(String.format("Nothing to update in '%s' for ID '%s'", saved.getClass().getSimpleName(), saved.getId().toString()));
			afterSave(obj, copy, Operations.Overwrite.class);
			return;
		}
		if (saved instanceof AbstractResource) {
			setAuditData((AbstractResource<ID>) obj, Operations.Overwrite.class);
		}
		save(saved);
		if (saved instanceof Auditable) {
			saveHistory(Actions.Crud.Overwrite, (Auditable) obj, changes, null);
		}

		afterSave(obj, copy, Operations.Overwrite.class);
		fireResourceChangeEvent(obj, Crud.Overwrite);
	}
	@SuppressWarnings("unchecked")
	private void updateInternal(ID id, T obj) {
		if (obj.getId() != null && !obj.getId().equals(id)) {
			throw new BadRequestException("ID field cannot be updated");
		}
		obj.setId(id);
		T saved = getById(id);
		ensureUniqueKeys(obj, saved, Operations.Update.class);
		beforeSave(obj, saved, Operations.Update.class);
		T copy = copy(saved);
		String changes = compareAndCopy(saved, obj);
		if (StringUtils.isEmpty(changes)) {
			LOG.info(String.format("Nothing to update in '%s' for ID '%s'", saved.getClass().getSimpleName(), saved.getId().toString()));
			afterSave(saved, copy, Operations.Update.class);
			return;
		}
		if (saved instanceof AbstractResource) {
			setAuditData((AbstractResource<ID>) saved, Operations.Update.class);
		}
		save(saved);
		if (saved instanceof Auditable) {
			saveHistory(Actions.Crud.Update, (Auditable) saved, changes, null);
		}

		afterSave(saved, copy, Operations.Update.class);
		fireResourceChangeEvent(saved, Crud.Update);
	}

	private T copy(T obj) {
		try {
			@SuppressWarnings("deprecation")
			T newObj = entityClass.newInstance();
			BeanUtils.copyProperties(newObj, obj);
			return newObj;
		} catch (InstantiationException | IllegalAccessException e) {
			throw new IllegalStateException(e);
		} catch (InvocationTargetException e) {
			throw new IllegalStateException(e);
		}

	}

	private void validate(T obj, Class<? extends Operations.Operation> operation) {
		Set<? extends ConstraintViolation<?>> errors = validator.validate(obj, operation);
		if (!errors.isEmpty()) {
			throw new ValidationException(errors);
		}
	}

	private void validate(List<T> objList, Class<? extends Operations.Operation> operation) {
		List<ValidationError> allErrors = new ArrayList<>();
		int i=0;
		for (T obj : objList) {
			i++;
			Set<ConstraintViolation<Object>> errors = validator.validate(obj, operation);
			List<ValidationError> errorsForObj = ValidationError.from(errors);
			setFieldIndex(errorsForObj, i);
		}

		if (!allErrors.isEmpty()) {
			throw new ValidationException(allErrors);
		}
	}
	private void ensureUniqueKeys(T newObj, T oldObj, Class<? extends Operations.Operation> operation) {
		/*
		 * TODO: Null checking of all values. It is possible to have null values for unique key fields
		 */
		if (uniqueKeyFields==null || uniqueKeyFields.isEmpty()) return;
		for (String key: uniqueKeyFields.keySet()) {
			List<Field> fields = uniqueKeyFields.get(key);
			List<Object> values = BeanUtil.getFieldValue(newObj, fields);
			List<Object> compareValues = new ArrayList<>();
			boolean validate=false;
			if (operation.equals(Operations.Add.class)) {
				//for add simply check if there are records for the same values
				// no need for checking when all unique key fields are null
				for (Object value: values) {
					if (value != null) {
						validate=true;
					}
				}
				compareValues=values;
			}else {
				/*
				 * for update it is complicated. Since there could be multiple fields in a unique key, below points are considered
				 * 1. First check if any of the field in the key has changed.
				 * 2. If any field has changed:
				 *    if the new value is null use the old value, otherwise the new value
				 */
				int i=0;
				List<Object> oldValues = BeanUtil.getFieldValue(oldObj, fields);
				for (Object oldValue: oldValues) {
					Object value = values.get(i);
					compareValues.add(value==null?oldValue:value);
					if (oldValue==null && value != null) {
						validate=true;
					}else if (value != null && !oldValue.equals(value)){
						validate=true;
					}
					i++;
				}
			}
			if (validate) {
				long count = EntityUtils.findRecordCount(entityClass, fields, compareValues);
				if (count > 0) {
					throw new ValidationException(key, UniqueKey.class.getSimpleName(), "must be unique");
				}
			}
		}
	}

	private void ensureNoReferences(T obj) {
		List<EntityReferenceCacheEntry> refs = staticCache.getEntityReferenceCache().getEntityReferences().get(obj.getClass());
		if (refs == null) {
			return;
		}

		List<ValidationError> errors = new ArrayList<>();
		for (EntityReferenceCacheEntry ref : refs) {
			long refCount = EntityUtils.findRecordCount(ref.getReferencedInEntity(), ref.getReferencedInField(), obj.getId());
			if (refCount != 0) {
				String msg = String.format("%d reference(s) found in '%s'", refCount, ref.getReferencedInEntity().getSimpleName());
				ValidationError error = new ValidationError(null,msg,null);
				errors.add(error);
			}
		}
		if (errors.size() != 0) {
			ErrorResponse resp = CommonResponseBuilder.errorResponse(null, null, errors);
			throw new InvalidRequestException(resp);
		}
	}

	private void verifyStatusField(T obj) {
		if (statusField == null) {
			return;
		}

		try {
			Object statusValue = FieldUtils.readField(statusField, obj, true);
			Object newValue = null;
			if (statusField.getType().equals(String.class)) {
				// set status if currently null or empty
				if (statusValue == null || StringUtils.isEmpty(statusValue.toString())) {
					newValue = statusFieldDefault;
				}
			} else if (statusField.getType().equals(Boolean.class)) {
				// boolean status true/false
				if (statusValue == null) {
					newValue = Boolean.valueOf(statusFieldDefault);
				}
			}
			if (newValue != null) {
				FieldUtils.writeField(statusField, obj, newValue, true);
			}
		} catch (IllegalAccessException e) {
			// should not happen. still do not eat the exception
			throw new IllegalStateException(e);
		}

	}

	private boolean isFieldReadOnly(Field field) {
		Schema annotation = field.getAnnotation(Schema.class);
		if (annotation != null) {
			Boolean readOnly = annotation.readOnly();
			if (readOnly) {
				return true;
			}
			/*
			AccessMode accessMode = annotation.accessMode();
			if (AccessMode.READ_ONLY.equals(accessMode)) {
				return true;
			}
			*/
		}
		return false;
	}
	private boolean isFieldTransient(Field field) {
		Transient transAnno = field.getAnnotation(Transient.class);
		if (transAnno != null) {
			return true;
		}
		return false;
	}
	protected void fireResourceChangeEvent(T obj, String action) {
		if (!(obj instanceof AppObect)) {
			return;
		}
//		AppObect res = (AppObect) obj;
	//	ResourceChangeEvent<AppObect> event = new ResourceChangeEvent<AppObect>(res, res.getAppObjectType(), action);
	//	publisher.publishEvent(event);
	}

	public void setAuditData(AbstractResource<ID> obj, Class<? extends Operations.Operation> operation) {
		if (operation.equals(Operations.Add.class)) {
			obj.setCreateDate(new Date());
			obj.setCreateUser(getLoggedUser());
		}
	}
	protected boolean isAdd(Class<? extends Operations.Operation> operation) {
		return Operations.Add.class.equals(operation);
	}
	protected boolean isUpdate(Class<? extends Operations.Operation> operation) {
		return Operations.Update.class.equals(operation);
	}
	protected boolean isOverwrite(Class<? extends Operations.Operation> operation) {
		return Operations.Overwrite.class.equals(operation);
	}
	protected boolean isBulk(Class<? extends Operations.Operation> operation) {
		return Operations.Bulk.class.equals(operation);
	}
	protected String getAppObjectType() {
		return entityClass.getSimpleName();
	}
}
